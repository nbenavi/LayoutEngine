// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#include "CoreUObjectPrivate.h"

/*-----------------------------------------------------------------------------
	UByteProperty.
-----------------------------------------------------------------------------*/
void UByteProperty::SerializeItem( FArchive& Ar, void* Value, void const* Defaults ) const
{
	if(Enum && Ar.UseToResolveEnumerators())
	{
		 const int32 ResolvedIndex = Enum->ResolveEnumerator(Ar, *(uint8*)Value);
		 *(uint8*)Value = static_cast<uint8>(ResolvedIndex);
		 return;
	}

	// Serialize enum values by name unless we're not saving or loading OR for backwards compatibility
	const bool bUseBinarySerialization = (Enum == NULL) || (!Ar.IsLoading() && !Ar.IsSaving());
	if( bUseBinarySerialization )
	{
		Super::SerializeItem(Ar, Value, Defaults);
	}
	// Loading
	else if (Ar.IsLoading())
	{
		FName EnumValueName;
		Ar << EnumValueName;
		// Make sure enum is properly populated
		if( Enum->HasAnyFlags(RF_NeedLoad) )
		{
			Ar.Preload(Enum);
		}

		// There's no guarantee EnumValueName is still present in Enum, in which case Value will be set to the enum's max value.
		// On save, it will then be serialized as NAME_None.
		*(uint8*)Value = Enum->FindEnumIndex(EnumValueName);
		if ( Enum->NumEnums() < *(uint8*)Value )
		{
			*(uint8*)Value = Enum->NumEnums() - 1;
		}
	}
	// Saving
	else
	{
		FName EnumValueName;
		uint8 ByteValue = *(uint8*)Value;

		// subtract 1 because the last entry in the enum's Names array
		// is the _MAX entry
		if ( ByteValue < Enum->NumEnums() - 1 )
		{
			EnumValueName = Enum->GetEnum(ByteValue);
		}
		else
		{
			EnumValueName = NAME_None;
		}
		Ar << EnumValueName;
	}
}
bool UByteProperty::NetSerializeItem( FArchive& Ar, UPackageMap* Map, void* Data, TArray<uint8> * MetaData ) const
{
	// -1 because the last item in the enum is the autogenerated _MAX item
	Ar.SerializeBits( Data, Enum ? FMath::CeilLogTwo(Enum->NumEnums() - 1) : 8 );
	return 1;
}
void UByteProperty::Serialize( FArchive& Ar )
{
	Super::Serialize( Ar );
	Ar << Enum;
	if (Enum != NULL)
	{
		Ar.Preload(Enum);
	}
}
void UByteProperty::AddReferencedObjects(UObject* InThis, FReferenceCollector& Collector)
{
	UByteProperty* This = CastChecked<UByteProperty>(InThis);
	Collector.AddReferencedObject( This->Enum, This );
	Super::AddReferencedObjects( This, Collector );
}
FString UByteProperty::GetCPPType( FString* ExtendedTypeText/*=NULL*/, uint32 CPPExportFlags/*=0*/ ) const
{
	if (Enum)
	{
		FString FullyQualifiedEnumName;
		if (!Enum->CppType.IsEmpty())
		{
			FullyQualifiedEnumName = Enum->CppType;
		}
		else
		{
			// This would give the wrong result if it's a namespaced type and the CppType hasn't
			// been set, but we do this here in case existing code relies on it... somehow.
			FullyQualifiedEnumName = Enum->GetName();
		}

		if ((CPPExportFlags & CPPF_ArgumentOrReturnValue) && ((PropertyFlags & CPF_ReturnParm) || !(PropertyFlags & CPF_OutParm)))
		{
			return FullyQualifiedEnumName;
		}
		else
		{
			return FString::Printf(TEXT("TEnumAsByte<%s>"), *FullyQualifiedEnumName);
		}
	}
	return Super::GetCPPType(ExtendedTypeText, CPPExportFlags);
}

void UByteProperty::ExportTextItem( FString& ValueStr, const void* PropertyValue, const void* DefaultValue, UObject* Parent, int32 PortFlags, UObject* ExportRootScope ) const
{
	if( Enum && (PortFlags & PPF_ConsoleVariable) == 0 )
	{
		// if the value is the max value (the autogenerated *_MAX value), export as "INVALID", unless we're exporting text for copy/paste (for copy/paste,
		// the property text value must actually match an entry in the enum's names array)
		ValueStr += ((*(const uint8*)PropertyValue < Enum->NumEnums() - 1 || ((PortFlags&PPF_Copy) != 0 && *(const uint8*)PropertyValue < Enum->NumEnums())) 
			? Enum->GetEnumName(*(const uint8*)PropertyValue) 
			: TEXT("(INVALID)"));
	}
	else
	{
		Super::ExportTextItem(ValueStr, PropertyValue, DefaultValue, Parent, PortFlags, ExportRootScope);
	}
}
const TCHAR* UByteProperty::ImportText_Internal( const TCHAR* InBuffer, void* Data, int32 PortFlags, UObject* Parent, FOutputDevice* ErrorText ) const
{
	FString Temp;
	if( Enum && (PortFlags & PPF_ConsoleVariable) == 0 )
	{
		const TCHAR* Buffer = UPropertyHelpers::ReadToken( InBuffer, Temp, true );
		if( Buffer != NULL )
		{
			const int32 EnumIndex = Enum->FindEnumIndex( *Temp );
			if( EnumIndex != INDEX_NONE )
			{
				*(uint8*)Data = EnumIndex;
				return Buffer;
			}
		}
	}
	return Super::ImportText_Internal( InBuffer, Data, PortFlags, Parent, ErrorText );
}

IMPLEMENT_CORE_INTRINSIC_CLASS(UByteProperty, UNumericProperty,
	{
		Class->EmitObjectReference(STRUCT_OFFSET(UByteProperty, Enum), TEXT("Enum"));
	}
);

